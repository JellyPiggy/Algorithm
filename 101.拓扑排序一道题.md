```java
//方法一
class DirectedGraphNode {
    public int label;
    public ArrayList<DirectedGraphNode> neighbors;

    public DirectedGraphNode(int label) {
        this.label = label;
        neighbors = new ArrayList<>();
    }
}

public class Code04_TopologicalSortingProblem {
    //key：各节点  value：当前 key 把各路径跑一次所过点次再+1(加上自己)
    public HashMap<DirectedGraphNode, Integer> nodeCounts = new HashMap<>();
    public ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph) {
        for (DirectedGraphNode cur : graph) {
            f(cur);
        }
        Set<DirectedGraphNode> keySet = nodeCounts.keySet();
        ArrayList<DirectedGraphNode> res = new ArrayList<>(keySet);
        Collections.sort(res, new Comparator<DirectedGraphNode>() {
            @Override
            public int compare(DirectedGraphNode o1, DirectedGraphNode o2) {
                return nodeCounts.get(o2) - nodeCounts.get(o1);
            }
        });
        return res;
    }

    //返回当前点的点次
    public int f(DirectedGraphNode cur) {
        //cur 的点次算过
        if (nodeCounts.containsKey(cur)) {
            return nodeCounts.get(cur);
        }
        int nodes = 0;
        // cur 的点次没算过
        for (DirectedGraphNode neighbor : cur.neighbors) {
            nodes += f(neighbor);
        }
        nodeCounts.put(cur, nodes + 1);
        return nodes + 1;
    }
}


//方法二
class Code04_TopologicalSortingProblem {

    //key：各节点  value：当前 key 的最大深度
    public HashMap<DirectedGraphNode, Integer> nodeDeep = new HashMap<>();

    public ArrayList<DirectedGraphNode> topSort(ArrayList<DirectedGraphNode> graph) {
        for (DirectedGraphNode node : graph) {
            f(node);
        }
        Set<DirectedGraphNode> keySet = nodeDeep.keySet();
        ArrayList<DirectedGraphNode> res = new ArrayList<>(keySet);
        Collections.sort(res, new Comparator<DirectedGraphNode>() {
            @Override
            public int compare(DirectedGraphNode o1, DirectedGraphNode o2) {
                return nodeDeep.get(o2) - nodeDeep.get(o1);
            }
        });
        return res;
    }

    //返回当前节点的最大深度
    public int f(DirectedGraphNode cur) {
        if (nodeDeep.containsKey(cur)) {
            return nodeDeep.get(cur);
        }
        int nextMaxDeep = 0;
        for (DirectedGraphNode neighbor : cur.neighbors) {
            nextMaxDeep = Math.max(nextMaxDeep, f(neighbor));
        }
        nodeDeep.put(cur, nextMaxDeep + 1);
        return nextMaxDeep + 1;
    }
}
```

